@startuml replication
participant "Unknown Role Node" as urn
participant "Master" as m
participant "Replica" as r
participant "Placement Driver" as pd

== 启动服务 ==
autonumber
urn -> pd: 携带想加入的group_id
pd -> urn: 返回角色信息 和 一些配置项
urn -> urn: 根据配置初始化

== 主从复制 ==
autonumber
pd -> urn: 通知变为Replica, 携带一些配置项
urn -> r: 变为Replica
note over r
   执行首次同步, 更新master不需要执行
end note
r -> r: 关闭全部slot binlog处理开关
r -> m: 发送"synccmd", 请求同步binlog
m -> r: synccmd
r -> m: 发送"snapshot 0", 请求master的snapshot
m -> r: list<slot_id,data>
r -> r: 处理完snapshot，打开全部binlog处理开关

== synccmd ==
autonumber
m -> m: 收到synccmd, 创建缓冲区，并且把binlog依次转发
loop
   m -> r: 转发 binlog (包括缓冲区的)
   r -> r: 收到binlog, 丢到本地的一个channel中，异步消费
   r -> r: 读取并判断
   opt binlog处理开关open && binlog的write_id 大于 Replica本地最小的write_id
      r -> r: 关闭binlog处理开关, await，等待notify
      r -> m: 发送"snapshot <slot_id>", 请求master的snapshot
      m -> r: list<slot_id,data>
      r -> r: 处理完snapshot，打开binlog处理开关, 并且notify
   end
   r -> m: 每秒有一次心跳
   r -> r: 发现断开，清理掉当前复制任务的task，重新建立连接发送 synccmd
end

note over m
   1. 在没有Replica的时候，Master没有缓冲区
   1. 转发binlog的时候携带write_id, 用于Replica丢弃没用(write_id小于本地)的数据
end note

== 主从切换(从变主) ==
autonumber
m -> pd:  heartbeat 所有的节点，每秒都会有heartbeat
pd -> pd: 发现一个master 超过10s 没有心跳，则选择一个group内，存活时间最长的replica作为新的master, 给他一个一分钟内边master的租期
pd -> r: 变成master
r -> r:  变成master，执行一些初始化动作
m -> pd: 发送master heartbeat
pd -> pd: 发现master heartbeat 已经改变，通知改group的所有节点更新master


@enduml