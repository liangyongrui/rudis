# 整体设计

## 目标

1. 对外的能力尽量 兼容 redis

   - 这样可以更好的复用 redis 的各种客户端能力
   - 各种基础的命令
   - Keyspace Notification
   - [acl](https://redis.io/topics/acl)

1. 比 redis 的效率更高

   - 全新数据引擎，充分利用多线程
   - 更高的 io 效率：io-uring
   - 对大 key 优化
   - 对热 key 优化

1. 比 redis 的坑更少

   - 使用 rust 减少各种内存安全上的 bug
   - 过期数据及时清理

1. 比 redis 更好运维

   - pd 模块
   - proxy

1. 比 redis 更强的扩展性

   - (这个还没想好)

1. 政治正确
   - 不使用 master、slave 等字眼

## 模块

1. core
   - 负责存储，可以单独使用
1. pd
   - raft 保障高可用
   - 协调主从
   - 协调 slot
   - 管理 group 级别的配置
   - 通知 proxy 主从、slot 的变更
   - 通知 client 主从、slot、proxy 的变更
   - 负载均衡 proxy，让 client 切换 proxy
   - 负载均衡 slot，动态迁移高频 slot
1. cloud proxy
   - slot 的 proxy, 使客户端可以使用非 cluster 模式的客户端
1. local proxy
   - 同上，部署在本地，减少一次网络开销

## 一些需要探索的方向

(可能有用的优化, tradeoff 的优化, 没想清楚的优化)

1. 单 slot 操作聚合
   - 避免频繁加锁, 增加吞吐
   - key 操作聚合
1. [使用其他内存分配器](https://poly000.github.io/perf-book-zh/heap-allocations_zh.html#%E4%BD%BF%E7%94%A8%E5%85%B6%E4%BB%96%E5%88%86%E9%85%8D%E5%99%A8)
1. 根据 value 的大小动态调整数据结构
   - rpds
1. 更高效的并发模型
   - 比如持久化数据结构
1. 集群事务
1. 从节点直接持久化保存, 减少从节点的内存成本
1. 主从多对一
1. 更可靠的主从复制
   1. 强一致性主从复制
      - 可能会增加单次耗时
      - 如果并发量比较大的话，吞吐量应该影响不大
1. 多主(多写)
   - [crdt](https://josephg.com/blog/crdts-go-brrr/)
   - [可能可以考虑用这个](https://github.com/josephg/diamond-types)
1. key 优化
   - https://github.com/BurntSushi/bstr
   - 比如 arc<[u8]>, 可以精简一个 weak reference, 每个 key 节约一个 byte
   - 小 key 可能不用 引用计数，直接 copy 就好, 每个 key 节约三个 byte, 如果是用 0 在结尾，还能再省点
1. [hashmap 优化](https://youtu.be/ncHmEUmJZf4?t=2861)
1. bit 类型 + [slab](https://docs.rs/slab/)
1. 热 slot 自动迁移
1. 直接用 rocketdb 存储
