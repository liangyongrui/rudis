@startuml Followertion

participant "Unknown Role Node" as urn
participant "Leader" as l
participant "Follower" as f
participant "Placement Driver" as pd

== 注册到pd ==
autonumber
urn -> pd: 加入group
note over urn
   携带的信息
   1. group_id: 想要加入的组
   2. role: 想要成为的角色
   3. node_id: 如果有的话 (连接意外断开重连的时候有)
   4. socket listener 地址
end note
pd -> urn: 返回一些配置信息

== Leader 加入服务 ==
urn -> pd: 加入group
pd -> pd: 几种情况处理
note over pd
   1. node_id 和现在的Leader node_id一致, 返回成功
   2. group中存在任意类型的节点, 返回 Leader已存在错误。
   3. group为空, 在pd层以 Candidate 角色保存,并返回成功
end note
pd -> urn: 失败或成功, 如果因为 Leader已存在 失败，执行从节点加入服务流程
note over urn
   携带的信息
   1. slot 分配情况
   2. node_id: 节点的唯一id
end note

== Leader 心跳处理 ==
l -> pd:  heartbeat, 如果发现连接已经断开，重新执行建立连接的流程
pd -> pd: 有几种情况
note over pd
   1. 发现 Leader heartbeat 的发送节点已经改变，设置改节点为Leader 并通知该group的所有节点更新Leader
   2. 发现当前没有Leader （可能是 Leader启动中），设置改节点为Leader 并通知该group的所有节点更新Leader
   3. Leader 的心跳正常，更新最新心跳时间
end note

== Follower 心跳处理 ==
f -> pd:  heartbeat, 如果发现连接已经断开，重新执行建立连接的流程
pd -> pd: 更新最新心跳时间

== Follower 加入服务(主从复制)==
autonumber
urn -> pd: 加入group
pd -> urn: 如果没有主节点，过10s重新加入，如果有的话，返回必要的信息
note over urn
   携带的信息
   1. slot 分配情况
   2. node_id: 节点的唯一id
   3. Leader 的主从复制地址
end note
urn -> f: 变为Follower
note over f
   执行首次同步, 更新Leader不需要执行
end note
f -> f: 关闭全部slot binlog处理开关
f -> l: 发送"synccmd", 请求同步binlog
l -> f: synccmd
f -> l: 发送"snapshot 0", 请求Leader的snapshot
l -> f: list<slot_id,data>
f -> f: 处理完snapshot，打开全部binlog处理开关

== synccmd ==
autonumber
l -> l: 收到synccmd, 创建缓冲区，并且把binlog依次转发
loop
   l -> f: 转发 binlog (包括缓冲区的)
   f -> f: 收到binlog, 丢到本地的一个channel中，异步消费
   f -> f: 读取并判断
   opt binlog处理开关open && binlog的write_id 大于 Follower本地最小的write_id
      f -> f: 关闭binlog处理开关, await，等待notify
      f -> l: 发送"snapshot <slot_id>", 请求Leader的snapshot
      l -> f: list<slot_id,data>
      f -> f: 处理完snapshot，打开binlog处理开关, 并且notify
   end
   f -> l: 每秒有一次心跳
   f -> f: 发现断开，清理掉当前复制任务的task，重新建立连接发送 synccmd
end

note over l
   1. 在没有Follower的时候，Leader没有缓冲区
   1. 转发binlog的时候携带write_id, 用于Follower丢弃没用(write_id小于本地)的数据
end note

== 主从切换(从变主) ==
autonumber
pd -> pd: 发现距离Leader最后一次超过10s, 重新选Leader
note over pd
   一些细节
   1. 选择一个group内存活时间最长的node作为新的Leader
   1. 设置group的状态为`Leader启动中`，一分钟后设置为普通
   1. `Leader启动中`状态下不再进行Leader心跳判断
end note
pd -> f: 变成Leader
f -> f:  变成Leader，执行一些初始化动作

@enduml